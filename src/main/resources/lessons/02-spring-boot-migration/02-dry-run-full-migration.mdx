---
title: Dry Run Full Migration
---

# Step 1: Run the full migration

First up, you can always start by running the full migration recipe that we ultimately want to finish with. This often gives us some information on some of the obvious pitfalls that we might run into, including incompatible libraries or additional customizations that we need to make to the recipe. Go ahead and run the upgrade Spring Boot 4.0 recipe now:

```bash
# Run the recipe
mod run $WORKSPACE --recipe io.moderne.java.spring.boot4.UpgradeSpringBoot_4_0

# Apply the suggested changes to all projects
mod git apply $WORKSPACE --last-recipe-run

# Build the projects to see if they compile
$WORKSHOP/build.sh
```

> Note: To ensure reproducible builds, projects refer to each other with specific release versions - not SNAPSHOTs or other dynamic references. This simulates an environment in a large organization where each of these repositories is owned by different teams and released independently. This probably isn't the case for _every_ repository in your portfolio - there's likely collections of related repositories that are all built and released together as a constellation of services. In our workshop, we'll simplify this to "every repository is independent from the others" to make sure we practice this particular speed bump.

Take a second to look at the output for the failed Maven builds. Why doesn't this work?

While every repository presents its own unique challenges, there are common speed bumps along the way that we can look for in any set of depositors. These include:

- Inconsistent or brittle build tool configuration
- Incompatible build tool versions (both the tools themselves and their plugins)
- Third-party dependencies that are incompatible with new versions of Java or upgraded frameworks
- Dependencies between repositories in the whole set that need to be built in order

In the example applications, we can see that there's actually a number of issues:

- We're failing to build some classes like `QOrder` and `QInventory`. These "Q" classes are coming from a code generator called QueryDSL, and code generators are a class of tools that are generally problematic during migrations. They often generate code that's specifically tuned for a particular version of Java or frameworks like Spring. Upgrading those runtimes often require an update to the code generator.
- We're seeing failures compiling test classes with errors like `package org.springframework.boot.test.autoconfigure.web.servlet does not exist`. Upgrading Spring also includes upgrading to a newer version of JUnit, so this might require us to update our tests, or we might be pulling in outdated testing libraries as dependencies.
- Errors like `'dependencies.dependency.version' for org.springframework.cloud:spring-cloud-starter-zipkin:jar is missing.` sounds like these used to be managed dependencies in our older Spring Boot versions but now there is no managed version specified in Spring Boot 4.0. This can happen when the dependency has move or been replaced by a different Spring Boot starter, or if the particular functionality was deprecated and removed.

## What makes a third-party library incompatible with newer versions of Java?

While you can run libraries compiled with an older version of Java in newer versions of JVM, the Java runtime has deprecated specific APIs and ultimately removed or refactored those as it has evolved. The major change that many people run into includes many `javax.*` internal APIs, including the Java EE APIs that were ultimately moved out of the JVM entirely and into the Jakarta namespace.

## Why do we care about dependencies between repositories as we're going through a migration?

Large organizations often have repositories that depend on each other, using internal shared libraries to share code and standardize specific functionality. These shared libraries can be owned, built, released, and versioned independently from the repositories that use them, so we need to upgrade these projects _and_ run them through their whole software developer lifecycle to release a new updated version that downstream consumers can move to. This can sometimes be as simple as upgrading a version number in a build manifest, or it can include complex code changes for those consumers to upgrade their code depending on how the libraries are built. 

Regardless, in order to upgrade all of our repositories, we often need to find the sets of repositories that are depended on and upgrade them first, then upgrade the rest in the proper sequence. For this workshop, we'll refer to each of these sets of repositories as "waves" of our migration.

We can use the Moderne CLI to apply any command across all of our repositories, including git commands. Go ahead and reset our repositories to a clean state now that we've learned from this experiment:

```bash
# Restore 
mod exec $WORKSPACE git restore MODERNE_BUILD_TOOL_DIR

# Rebuild the LST
$WORKSHOP/build.sh
mod build $WORKSPACE
```